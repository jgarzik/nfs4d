/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <errno.h>
#include <glib.h>
#include "nfs4_prot.h"
#include "server.h"

static int debugging = 1;

/* "djb2"-derived hash function */
static unsigned long blob_hash(const void *_buf, size_t buflen)
{
	const unsigned char *buf = _buf;
	unsigned long hash = 5381UL;
	int c;

	while (buflen > 0) {
		c = *buf++;
		buflen--;

		hash = ((hash << 5) + hash) ^ c; /* hash * 33 ^ c */
	}

	return hash;
}

static guint blob_hash_for_key(const struct blob *b)
{
	return blob_hash(b->buf, b->len);
}

static gboolean blob_equal(const struct blob *a, const struct blob *b)
{
	if (a->len != b->len)
		return FALSE;
	if (memcmp(a->buf, b->buf, a->len))
		return FALSE;
	return TRUE;
}

static void nrand32(void *mem, unsigned int dwords)
{
	guint32 *v = mem;
	long l;
	int i;

	for (i = 0; i < dwords; i++) {
		l = 0;
		lrand48_r(&srv.rng, &l);

		v[i] = l;
	}
}

static void rand_verifier(verifier4 *verf)
{
	nrand32(verf, 5);
}

static void gen_clientid4(clientid4 *id)
{
	int loop = 1000000;
	memset(id, 0, sizeof(*id));

	do {
		if (G_UNLIKELY(loop == 0)) {
			syslog(LOG_ERR, "gen_clientid: 1,000,000 collisions");
			return;
		}

		loop--;

		nrand32(id, 2);
	} while (g_hash_table_lookup(srv.clid_idx, id) != NULL);
}

bool_t nfsproc4_null_4_svc(void *argp, void *result, struct svc_req *rqstp)
{
	return TRUE;
}

bool_t valid_utf8string(utf8string *str)
{
	if (!str || !str->utf8string_len || !str->utf8string_val)
		return FALSE;
	if (!g_utf8_validate(str->utf8string_val, str->utf8string_len, NULL))
		return FALSE;
	return TRUE;
}

gchar *copy_utf8string(utf8string *str)
{
	return g_strndup(str->utf8string_val, str->utf8string_len);
}

bool_t has_dots(utf8string *str)
{
	if (!str)
		return FALSE;
	if ((str->utf8string_len == 1) &&
	    (!memcmp(str->utf8string_val, ".", 1)))
		return TRUE;
	if ((str->utf8string_len == 2) &&
	    (!memcmp(str->utf8string_val, "..", 2)))
		return TRUE;
	return FALSE;
}

guint64 get_bitmap(const bitmap4 *map)
{
	guint64 v = 0;

	if (map->bitmap4_len > 0)
		v |= map->bitmap4_val[0];
	if (map->bitmap4_len > 1)
		v |= ((guint64)map->bitmap4_val[1]) << 32;
	return v;
}

int set_bitmap(guint64 map_in, bitmap4 *map_out)
{
	map_out->bitmap4_len = 2;
	map_out->bitmap4_val = g_new(uint32_t, 2);
	if (!map_out->bitmap4_val) {
		map_out->bitmap4_len = 0;
		return -1;
	}

	map_out->bitmap4_val[0] = map_in;
	map_out->bitmap4_val[1] = (map_in >> 32);

	return 0;
}

static struct nfs_client *cli_init(struct svc_req *rqstp)
{
	struct nfs_client *cli = g_slice_new0(struct nfs_client);

	return cli;
}

static void cli_free(struct nfs_client *cli)
{
	g_slice_free(struct nfs_client, cli);
}

void nfs_fh_set(nfs_fh4 *fh, nfsino_t fh_int)
{
	nfsino_t *fh_val = g_slice_new(nfsino_t);
	*fh_val = GUINT32_TO_BE(fh_int);

	fh->nfs_fh4_len = sizeof(nfsino_t);
	fh->nfs_fh4_val = (char *)(void *) fh_val;
}

static void nfs_fh_free(nfs_fh4 *fh)
{
	if (fh) {
		nfsino_t *fh_val = (void *) fh->nfs_fh4_val;
		g_slice_free(nfsino_t, fh_val);
		fh->nfs_fh4_val = NULL;
	}
}

nfsino_t nfs_fh_decode(const nfs_fh4 *fh_in)
{
	nfsino_t *fhp;
	nfsino_t fh;

	if (!fh_in)
		return 0;
	if (fh_in->nfs_fh4_len != sizeof(nfsino_t))
		return 0;
	if (!fh_in->nfs_fh4_val)
		return 0;
	fhp = (void *) fh_in->nfs_fh4_val;
	fh = GUINT32_FROM_BE(*fhp);

	if (!inode_get(fh))
		return 0;

	return fh;
}

bool_t push_resop(COMPOUND4res *res, const nfs_resop4 *resop, nfsstat4 stat)
{
	void *mem;
	u_int array_len = res->resarray.resarray_len;

	mem = realloc(res->resarray.resarray_val,
		((array_len + 1) * sizeof(nfs_resop4)));
	if (!mem)
		return FALSE;

	res->resarray.resarray_len++;
	res->resarray.resarray_val = mem;
	memcpy(&res->resarray.resarray_val[array_len], resop,
	       sizeof(struct nfs_resop4));
	res->status = stat;

	return TRUE;
}

static void nfs_getfh_free(GETFH4res *opgetfh)
{
	nfs_fh_free(&opgetfh->GETFH4res_u.resok4.object);
}

static bool_t nfs_op_getfh(struct nfs_client *cli, COMPOUND4res *cres)
{
	struct nfs_resop4 resop;
	GETFH4res *res;
	GETFH4resok *resok;
	nfsstat4 status = NFS4_OK;

	memset(&resop, 0, sizeof(resop));
	resop.resop = OP_GETFH;
	res = &resop.nfs_resop4_u.opgetfh;
	resok = &res->GETFH4res_u.resok4;

	if (debugging)
		syslog(LOG_INFO, "CURRENT_FH == %u", cli->current_fh);

	if (!inode_get(cli->current_fh)) {
		status = NFS4ERR_NOFILEHANDLE;
		goto out;
	}

	nfs_fh_set(&resok->object, cli->current_fh);

out:
	res->status = status;
	return push_resop(cres, &resop, status);
}

static bool_t nfs_op_putfh(struct nfs_client *cli, PUTFH4args *arg, COMPOUND4res *cres)
{
	struct nfs_resop4 resop;
	PUTFH4res *res;
	nfsstat4 status = NFS4_OK;
	nfsino_t fh;

	memset(&resop, 0, sizeof(resop));
	resop.resop = OP_PUTFH;
	res = &resop.nfs_resop4_u.opputfh;

	fh = nfs_fh_decode(&arg->object);
	if (!fh) {
		status = NFS4ERR_BADHANDLE;
		goto out;
	}

	cli->current_fh = fh;

out:
	res->status = status;
	return push_resop(cres, &resop, status);
}

static bool_t nfs_op_putrootfh(struct nfs_client *cli, COMPOUND4res *cres)
{
	struct nfs_resop4 resop;
	PUTFH4res *res;
	nfsstat4 status = NFS4_OK;

	memset(&resop, 0, sizeof(resop));
	resop.resop = OP_PUTROOTFH;
	res = &resop.nfs_resop4_u.opputfh;

	cli->current_fh = INO_ROOT;

	res->status = status;
	return push_resop(cres, &resop, status);
}

static bool_t nfs_op_putpubfh(struct nfs_client *cli, COMPOUND4res *cres)
{
	struct nfs_resop4 resop;
	PUTFH4res *res;
	nfsstat4 status = NFS4_OK;

	memset(&resop, 0, sizeof(resop));
	resop.resop = OP_PUTPUBFH;
	res = &resop.nfs_resop4_u.opputfh;

	cli->current_fh = INO_ROOT;

	res->status = status;
	return push_resop(cres, &resop, status);
}

static bool_t nfs_op_restorefh(struct nfs_client *cli, COMPOUND4res *cres)
{
	struct nfs_resop4 resop;
	RESTOREFH4res *res;
	nfsstat4 status = NFS4_OK;

	memset(&resop, 0, sizeof(resop));
	resop.resop = OP_RESTOREFH;
	res = &resop.nfs_resop4_u.oprestorefh;

	if (!inode_get(cli->save_fh)) {
		status = NFS4ERR_RESTOREFH;
		goto out;
	}

	cli->current_fh = cli->save_fh;

out:
	res->status = status;
	return push_resop(cres, &resop, status);
}

static bool_t nfs_op_savefh(struct nfs_client *cli, COMPOUND4res *cres)
{
	struct nfs_resop4 resop;
	SAVEFH4res *res;
	nfsstat4 status = NFS4_OK;

	memset(&resop, 0, sizeof(resop));
	resop.resop = OP_SAVEFH;
	res = &resop.nfs_resop4_u.opsavefh;

	if (!inode_get(cli->current_fh)) {
		status = NFS4ERR_NOFILEHANDLE;
		goto out;
	}

	cli->save_fh = cli->current_fh;

out:
	res->status = status;
	return push_resop(cres, &resop, status);
}

static bool_t nfs_op_readlink(struct nfs_client *cli, COMPOUND4res *cres)
{
	struct nfs_resop4 resop;
	READLINK4res *res;
	READLINK4resok *resok;
	nfsstat4 status = NFS4_OK;
	struct nfs_inode *ino;
	gchar *linktext;

	memset(&resop, 0, sizeof(resop));
	resop.resop = OP_READLINK;
	res = &resop.nfs_resop4_u.opreadlink;
	resok = &res->READLINK4res_u.resok4;

	ino = inode_get(cli->current_fh);
	if (!ino) {
		status = NFS4ERR_NOFILEHANDLE;
		goto out;
	}
	if (ino->type != NF4LNK) {
		status = NFS4ERR_NOFILEHANDLE;
		goto out;
	}

	linktext = ino->u.linktext;
	g_assert(linktext != NULL);

	resok->link.utf8string_len = strlen(linktext);
	resok->link.utf8string_val = linktext;

out:
	res->status = status;
	return push_resop(cres, &resop, status);
}

static int copy_cb_client4(cb_client4 *dest, const cb_client4 *src)
{
	int rc = -ENOMEM;

	dest->cb_program = src->cb_program;

	dest->cb_location.r_netid = g_strdup(src->cb_location.r_netid);
	if (!dest->cb_location.r_netid)
		goto err_out;

	dest->cb_location.r_addr = g_strdup(src->cb_location.r_addr);
	if (!dest->cb_location.r_addr)
		goto err_out_1;

	return 0;

err_out_1:
	g_free(dest->cb_location.r_netid);
err_out:
	return rc;
}

static void free_cb_client4(cb_client4 *cbc)
{
	g_free(cbc->cb_location.r_netid);
	g_free(cbc->cb_location.r_addr);
}

static void clientid_free(struct nfs_clientid *id)
{
	if (!id)
		return;
	
	g_free(id->id.buf);
	free_cb_client4(&id->callback);
	g_slice_free(struct nfs_clientid, id);
}

void state_free(gpointer data)
{
	struct nfs_state *st = data;

	clientid_free(st->id);

	if (st->pending) {
		GList *tmp = st->pending;
		while (tmp) {
			clientid_free(tmp->data);
			tmp = tmp->next;
		}
		g_list_free(st->pending);
	}

	g_slice_free(struct nfs_state, st);
}

guint clientid_hash(gconstpointer key)
{
	const struct nfs_clientid *clid = key;
	return blob_hash_for_key(&clid->id);
}

gboolean clientid_equal(gconstpointer _a, gconstpointer _b)
{
	const struct nfs_clientid *a = _a;
	const struct nfs_clientid *b = _b;
	return blob_equal(&a->id, &b->id);
}

guint short_clientid_hash(gconstpointer key)
{
	const clientid4 *clid = key;
	return *clid;
}

gboolean short_clientid_equal(gconstpointer _a, gconstpointer _b)
{
	const clientid4 *a = _a;
	const clientid4 *b = _b;
	return (*a == *b) ? TRUE : FALSE;
}

static int clientid_new(struct nfs_state *st, struct nfs_client *cli,
			SETCLIENTID4args *args, struct nfs_clientid **clid_out)
{
	struct nfs_clientid *clid;
	clientid4 *short_clid;

	clid = g_slice_new0(struct nfs_clientid);
	if (!clid)
		goto err_out;

	/* copy client id */
	clid->id.len = args->client.id.id_len;
	clid->id.buf = g_memdup(args->client.id.id_val, clid->id.len);
	if (!clid->id.buf)
		goto err_out_clid;

	/* copy client verifier */
	memcpy(&clid->cli_verf, &args->client.verifier, sizeof(verifier4));

	/* generate shorthand client id, random SETCLIENTID_CONFIRM verifier */
	gen_clientid4(&clid->id_short);
	rand_verifier(&clid->confirm_verf);

	/* copy callback info */
	if (copy_cb_client4(&clid->callback, &args->callback))
		goto err_out_clid_buf;
	clid->callback_ident = args->callback_ident;

	short_clid = g_memdup(&clid->id_short, sizeof(clientid4));
	if (!short_clid)
		goto err_out_cb_client4;

	g_hash_table_insert(srv.clid_idx, short_clid, st);

	*clid_out = clid;
	return 0;

err_out_cb_client4:
	free_cb_client4(&clid->callback);
err_out_clid_buf:
	g_free(clid->id.buf);
err_out_clid:
	g_slice_free(struct nfs_clientid, clid);
err_out:
	return -ENOMEM;
}

static int state_new(struct nfs_client *cli, SETCLIENTID4args *args,
		     struct nfs_clientid **clid_out)
{
	struct nfs_state *st;
	struct nfs_clientid *clid = NULL;
	int rc = -ENOMEM;

	st = g_slice_new0(struct nfs_state);
	if (!st)
		goto err_out;

	rc = clientid_new(st, cli, args, &clid);
	if (rc)
		goto err_out_st;
	
	/* add to state's client-id pending list */
	st->pending = g_list_prepend(st->pending, clid);

	/* add to global list of client ids */
	g_hash_table_insert(srv.client_ids, clid, st);

	*clid_out = clid;
	return 0;

err_out_st:
	g_slice_free(struct nfs_state, st);
err_out:
	return rc;
}

static gboolean callback_equal(struct nfs_state *st, cb_client4 *cb,
			       uint32_t cb_ident)
{
	struct nfs_clientid *clid;

	if (!st)
		return FALSE;
	if (!st->id)
		return FALSE;

	clid = st->id;
	if (clid->callback_ident != cb_ident)
		return FALSE;
	if (clid->callback.cb_program != cb->cb_program)
		return FALSE;
	if (!cb->cb_location.r_addr || !cb->cb_location.r_netid)
		return FALSE;
	if (strcmp(clid->callback.cb_location.r_netid,
		   cb->cb_location.r_netid))
		return FALSE;
	if (strcmp(clid->callback.cb_location.r_addr,
		   cb->cb_location.r_addr))
		return FALSE;
	
	return TRUE;
}

static bool_t nfs_op_setclientid(struct nfs_client *cli, SETCLIENTID4args *args,
				 COMPOUND4res *cres)
{
	struct nfs_resop4 resop;
	SETCLIENTID4res *res;
	SETCLIENTID4resok *resok;
	nfsstat4 status = NFS4_OK;
	struct nfs_state *st;
	int rc;
	struct nfs_clientid *clid = NULL, clid_key;

	memset(&resop, 0, sizeof(resop));
	resop.resop = OP_SETCLIENTID;
	res = &resop.nfs_resop4_u.opsetclientid;
	resok = &res->SETCLIENTID4res_u.resok4;

	/* look up client id */
	memset(&clid_key, 0, sizeof(clid_key));
	clid_key.id.len = args->client.id.id_len;
	clid_key.id.buf = args->client.id.id_val;
	st = g_hash_table_lookup(srv.client_ids, &clid_key);

	if (!st) {
		rc = state_new(cli, args, &clid);
		if (rc < 0) {
			status = NFS4ERR_RESOURCE;
			goto out;
		}
	}

	else if ((!st->id) ||
		 (memcmp(&st->id->cli_verf, &args->client.verifier,
		 	 sizeof(verifier4))) ||
		 (!callback_equal(st, &args->callback,
		 		  args->callback_ident))) {

		rc = clientid_new(st, cli, args, &clid);
		if (rc < 0) {
			status = NFS4ERR_RESOURCE;
			goto out;
		}

		/* add to state's client-id pending list */
		st->pending = g_list_prepend(st->pending, clid);
	}

	else {
		clid = st->id;
	}

	g_assert(clid != NULL);

	resok->clientid = clid->id_short;
	memcpy(&resok->setclientid_confirm, &clid->confirm_verf,
	       sizeof(verifier4));

out:
	res->status = status;
	return push_resop(cres, &resop, status);
}

static bool_t nfs_op_setclientid_confirm(struct nfs_client *cli,
					 SETCLIENTID_CONFIRM4args *arg,
					 COMPOUND4res *cres)
{
	struct nfs_resop4 resop;
	SETCLIENTID_CONFIRM4res *res;
#if 0
	nfsstat4 status = NFS4_OK;
#else
	nfsstat4 status = NFS4ERR_NOTSUPP;
#endif

	memset(&resop, 0, sizeof(resop));
	resop.resop = OP_SETCLIENTID_CONFIRM;
	res = &resop.nfs_resop4_u.opsetclientid_confirm;

	/* FIXME */

#if 0
out:
#endif
	res->status = status;
	return push_resop(cres, &resop, status);
}

static bool_t nfs_op_notsupp(struct nfs_client *cli, COMPOUND4res *cres,
			     nfs_opnum4 argop)
{
	struct nfs_resop4 resop;
	OPENATTR4res *res;
	nfsstat4 status = NFS4ERR_NOTSUPP;

	memset(&resop, 0, sizeof(resop));
	resop.resop = argop;
	res = &resop.nfs_resop4_u.opopenattr;
	res->status = status;
	return push_resop(cres, &resop, status);
}

static const char *arg_str[] = {
	"<n/a>",
	"<n/a>",
	"<n/a>",
	"ACCESS",
	"CLOSE",
	"COMMIT",
	"CREATE",
	"DELEGPURGE",
	"DELEGRETURN",
	"GETATTR",
	"GETFH",
	"LINK",
	"LOCK",
	"LOCKT",
	"LOCKU",
	"LOOKUP",
	"LOOKUPP",
	"NVERIFY",
	"OPEN",
	"OPENATTR",
	"OPEN_CONFIRM",
	"OPEN_DOWNGRADE",
	"PUTFH",
	"PUTPUBFH",
	"PUTROOTFH",
	"READ",
	"READDIR",
	"READLINK",
	"REMOVE",
	"RENAME",
	"RENEW",
	"RESTOREFH",
	"SAVEFH",
	"SECINFO",
	"SETATTR",
	"SETCLIENTID",
	"SETCLIENTID_CONFIRM",
	"VERIFY",
	"WRITE",
	"RELEASE_LOCKOWNER",
};

static bool_t nfs_arg(struct nfs_client *cli, nfs_argop4 *arg, COMPOUND4res *res)
{
	if (debugging)
		syslog(LOG_INFO, "compound op %s",
		       (arg->argop > 39) ?  "<n/a>" : arg_str[arg->argop]);

	switch (arg->argop) {
	case OP_ACCESS:
		return nfs_op_access(cli, &arg->nfs_argop4_u.opaccess, res);
	case OP_CREATE:
		return nfs_op_create(cli, &arg->nfs_argop4_u.opcreate, res);
	case OP_GETATTR:
		return nfs_op_getattr(cli, &arg->nfs_argop4_u.opgetattr, res);
	case OP_GETFH:
		return nfs_op_getfh(cli, res);
	case OP_LINK:
		return nfs_op_link(cli, &arg->nfs_argop4_u.oplink, res);
	case OP_LOOKUP:
		return nfs_op_lookup(cli, &arg->nfs_argop4_u.oplookup, res);
	case OP_LOOKUPP:
		return nfs_op_lookupp(cli, res);
	case OP_NVERIFY:
		return nfs_op_verify(cli,
				(VERIFY4args *) &arg->nfs_argop4_u.opnverify,
				res, 1);
	case OP_PUTFH:
		return nfs_op_putfh(cli, &arg->nfs_argop4_u.opputfh, res);
	case OP_PUTPUBFH:
		return nfs_op_putpubfh(cli, res);
	case OP_PUTROOTFH:
		return nfs_op_putrootfh(cli, res);
	case OP_READLINK:
		return nfs_op_readlink(cli, res);
	case OP_REMOVE:
		return nfs_op_remove(cli, &arg->nfs_argop4_u.opremove, res);
	case OP_RENAME:
		return nfs_op_rename(cli, &arg->nfs_argop4_u.oprename, res);
	case OP_RESTOREFH:
		return nfs_op_restorefh(cli, res);
	case OP_SAVEFH:
		return nfs_op_savefh(cli, res);
	case OP_SETCLIENTID:
		return nfs_op_setclientid(cli,
					&arg->nfs_argop4_u.opsetclientid, res);
	case OP_SETCLIENTID_CONFIRM:
		return nfs_op_setclientid_confirm(cli,
				&arg->nfs_argop4_u.opsetclientid_confirm, res);
	case OP_VERIFY:
		return nfs_op_verify(cli, &arg->nfs_argop4_u.opverify, res, 0);

	case OP_CLOSE:
	case OP_COMMIT:
	case OP_DELEGPURGE:
	case OP_DELEGRETURN:
	case OP_LOCK:
	case OP_LOCKT:
	case OP_LOCKU:
	case OP_OPEN:
	case OP_OPEN_CONFIRM:
	case OP_OPEN_DOWNGRADE:
	case OP_READ:
	case OP_READDIR:
	case OP_RENEW:
	case OP_SECINFO:
	case OP_SETATTR:
	case OP_WRITE:
	case OP_RELEASE_LOCKOWNER:
	case OP_OPENATTR:
		return nfs_op_notsupp(cli, res, arg->argop);
	default:
		return FALSE;
	}

	return FALSE;	/* never reached */
}

bool_t nfsproc4_compound_4_svc(COMPOUND4args *arg, COMPOUND4res *res,
			       struct svc_req *rqstp)
{
	struct nfs_client *cli;
	unsigned int i;

	memset(res, 0, sizeof(*res));
	res->status = NFS4_OK;
	memcpy(&res->tag, &arg->tag, sizeof(utf8str_cs));

	if (arg->minorversion != 0) {
		res->status = NFS4ERR_MINOR_VERS_MISMATCH;
		goto out;
	}

	cli = cli_init(rqstp);
	if (!cli) {
		res->status = NFS4ERR_RESOURCE;
		goto out;
	}

	if (debugging)
		syslog(LOG_INFO, "compound start");

	for (i = 0; i < arg->argarray.argarray_len; i++)
		if (!nfs_arg(cli, &arg->argarray.argarray_val[i], res)) {
			syslog(LOG_WARNING, "compound failed early");
			break;
		}

	if (debugging)
		syslog(LOG_INFO, "compound stop");

	cli_free(cli);
out:
	return TRUE;
}

static void nfs_free(nfs_resop4 *res)
{
	switch(res->resop) {
	case OP_CREATE:
		g_free(res->nfs_resop4_u.opcreate.CREATE4res_u.resok4.attrset.bitmap4_val);
		break;
	case OP_GETATTR:
		nfs_getattr_free(&res->nfs_resop4_u.opgetattr);
		break;
	case OP_GETFH:
		nfs_getfh_free(&res->nfs_resop4_u.opgetfh);
		break;
	default:
		/* nothing to free */
		break;
	}
}

int nfs4_program_4_freeresult (SVCXPRT *transp, xdrproc_t xdr_result,
			       COMPOUND4res *res)
{
	unsigned int i;

	for (i = 0; i < res->resarray.resarray_len; i++)
		nfs_free(&res->resarray.resarray_val[i]);

	free(res->resarray.resarray_val);

	return TRUE;
}

